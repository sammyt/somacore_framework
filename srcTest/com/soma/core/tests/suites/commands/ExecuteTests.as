package com.soma.core.tests.suites.commands {
	import flash.events.Event;
	import org.flexunit.async.Async;
	import com.soma.core.tests.suites.support.TestAsyncCommand;
	import com.soma.core.tests.suites.support.EmptyModel;
	import org.flexunit.asserts.assertEquals;
	import com.soma.core.tests.suites.support.TestParallelCommand;
	import org.flexunit.asserts.fail;
	import org.flexunit.asserts.assertFalse;
	import flash.display.Sprite;
	import org.flexunit.asserts.assertTrue;
	import com.soma.core.tests.suites.support.TestCommand;
	import com.soma.core.tests.suites.support.TestEvent;
	import com.soma.core.interfaces.ISoma;
	import com.soma.core.Soma;
	import flash.display.Stage;
	import mx.core.FlexGlobals;
		/**	 * <b>Author:</b> Romuald Quantin - <a href="http://www.soundstep.com/" target="_blank">www.soundstep.com</a><br />	 * <b>Class version:</b> 1.0<br />	 * <b>Actionscript version:</b> 3.0<br />	 * <b>Date:</b> Oct 9, 2010<br />	 * @example	 * <listing version="3.0"></listing>	 */		public class ExecuteTests {		
		private var _soma:ISoma;
		private var _executed:Boolean;		private var _executedCount:int;		private var _spriteTestAccess:Sprite;		private var _userAccessFromInstance:Boolean;		private var _userAccessFromInstanceCount:int;		private var _userAccessFromDisplayList:Boolean;
		
		private static var _stage:Stage;
				[BeforeClass]		public static function runBeforeClass():void {			_stage = FlexGlobals.topLevelApplication.stage;		}				[AfterClass]		public static function runAfterClass():void {			_stage = null;
		} 				[Before]		public function runBefore():void {			_executed = false;			_executedCount = 0;			_userAccessFromInstance = false;			_userAccessFromInstanceCount = 0;			_userAccessFromDisplayList = false;			_soma = new Soma(_stage);			_soma.addCommand(TestEvent.TEST, TestCommand);
			_soma.addEventListener(TestEvent.TEST, setUserAccessFromInstance);			_spriteTestAccess = new Sprite();
			_spriteTestAccess.addEventListener(TestEvent.TEST, setUserAccessFromDisplayList);			_stage.addChild(_spriteTestAccess);		}				[After]		public function runAfter():void {			_stage.removeChild(_spriteTestAccess);			_spriteTestAccess.removeEventListener(TestEvent.TEST, setUserAccessFromDisplayList);
			_spriteTestAccess = null;			_soma.removeEventListener(TestEvent.TEST, setUserAccessFromInstance);			_soma.dispose();			_soma = null;		}				[Test]		public function testCommandFromDisplayList():void {
			_spriteTestAccess.dispatchEvent(new TestEvent(TestEvent.TEST, this));			defaultCheck();			assertTrue(_executed);
		}

		[Test]		public function testCommandFromDisplayListBubblesFalse():void {			_spriteTestAccess.dispatchEvent(new TestEvent(TestEvent.TEST, this, false));
			defaultCheck();			assertFalse(_executed);		}		[Test]		public function testCommandFromInstance():void {			_soma.dispatchEvent(new TestEvent(TestEvent.TEST, this));			defaultCheck();			assertTrue(_executed);		}		[Test]		public function testCommandFromInstanceBubblesFalse():void {			_soma.dispatchEvent(new TestEvent(TestEvent.TEST, this, false));			defaultCheck();			assertFalse(_executed);		}		[Test]		public function testCommandFromStage():void {			_stage.dispatchEvent(new TestEvent(TestEvent.TEST, this));			defaultCheck();			assertTrue(_executed);		}		[Test]		public function testCommandFromStageBubblesFalse():void {			_stage.dispatchEvent(new TestEvent(TestEvent.TEST, this, false));			defaultCheck();			assertFalse(_executed);		}		[Test]		public function testCancelEventDispatchedFromInstance():void {			_soma.addEventListener(TestEvent.TEST, cancelEvent);			_soma.dispatchEvent(new TestEvent(TestEvent.TEST, this));			assertFalse(_executed);			_soma.removeEventListener(TestEvent.TEST, cancelEvent);		}		[Test]		public function testCouldNotCancelEventDispatchedFromInstance():void {			_soma.addEventListener(TestEvent.TEST, cancelEvent);			_soma.dispatchEvent(new TestEvent(TestEvent.TEST, this, true, false));			assertTrue(_executed);			_soma.removeEventListener(TestEvent.TEST, cancelEvent);		}		[Test]		public function testCancelEventDispatchedFromDisplayList():void {			_soma.addEventListener(TestEvent.TEST, cancelEvent);			_spriteTestAccess.dispatchEvent(new TestEvent(TestEvent.TEST, this));			assertFalse(_executed);			_spriteTestAccess.removeEventListener(TestEvent.TEST, cancelEvent);		}		[Test]		public function testCouldNotCancelEventDispatchedFromDisplayList():void {			_soma.addEventListener(TestEvent.TEST, cancelEvent);			_spriteTestAccess.dispatchEvent(new TestEvent(TestEvent.TEST, this, true, false));			assertTrue(_executed);			_spriteTestAccess.removeEventListener(TestEvent.TEST, cancelEvent);		}		[Test]		public function testCancelEventDispatchedFromStage():void {			_soma.addEventListener(TestEvent.TEST, cancelEvent);			_stage.dispatchEvent(new TestEvent(TestEvent.TEST, this));			assertFalse(_executed);			_stage.removeEventListener(TestEvent.TEST, cancelEvent);		}		[Test]		public function testCouldNotCancelEventDispatchedFromStage():void {			_soma.addEventListener(TestEvent.TEST, cancelEvent);			_stage.dispatchEvent(new TestEvent(TestEvent.TEST, this, true, false));			assertTrue(_executed);			_stage.removeEventListener(TestEvent.TEST, cancelEvent);		}		[Test]		public function testParallelCommand():void {			var soma:ISoma = new Soma(_stage);			soma.addCommand(TestEvent.TEST, TestCommand);			soma.addCommand(TestEvent.TEST_PARALLEL, TestParallelCommand);			soma.addModel(EmptyModel.NAME, new EmptyModel(this));			soma.dispatchEvent(new TestEvent(TestEvent.TEST_PARALLEL));			assertEquals(_executedCount, 5);			soma.dispose();			soma = null;		}				[Test(async)]		public function testAsyncCommand():void {			var soma:ISoma = new Soma(_stage);
			soma.addCommand(TestEvent.TEST, TestAsyncCommand);
			soma.addEventListener(TestEvent.TEST_ASYNC_COMPLETE, Async.asyncHandler(this, testAsyncCommandSuccess, 500, soma, testAsyncCommandFailed), false, 0, true);			soma.dispatchEvent(new TestEvent(TestEvent.TEST));		}		private function testAsyncCommandFailed(instance:ISoma):void {			fail("AsyncCommand has not been executed under 500ms");			instance.dispose();			instance = null;		}				private function testAsyncCommandSuccess(event:Event, instance:ISoma):void {			instance.dispose();			instance = null;		}				private function defaultCheck():void {			if (_executed && !_userAccessFromInstance) fail("User did not have access to the command from the framework");
			else if (_userAccessFromInstanceCount > 1) fail("User had access to the command from the framework twice");
			else if (_executed && _userAccessFromDisplayList) fail("User had access to the command from the display list");			else if (_executedCount > 1) fail("Command has been executed twice");		}		private function cancelEvent(event:TestEvent):void {			event.preventDefault();		}		public function setToExecuted():void {			_executedCount++;			_executed = true;		}				private function setUserAccessFromInstance(e:TestEvent):void {			_userAccessFromInstance = true;			_userAccessFromInstanceCount++;		}				private function setUserAccessFromDisplayList(e:TestEvent):void {			_userAccessFromDisplayList = true;		}			}}